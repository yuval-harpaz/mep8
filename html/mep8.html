
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>mep8</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-10-11"><meta name="DC.source" content="mep8.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Input - output</a></li><li><a href="#4">features:</a></li><li><a href="#5">cfg options</a></li><li><a href="#6">To Do</a></li><li><a href="#7">website</a></li><li><a href="#8">Assign default values</a></li><li><a href="#9">check compatibility / code warnings</a></li><li><a href="#10">read text file</a></li><li><a href="#11">use matlab automatic indentation to add / remove spaces</a></li><li><a href="#12">look for '=' or other stuff to pad with spaces</a></li><li><a href="#13">variable names</a></li><li><a href="#14">line length 80?</a></li><li><a href="#15">overwrite if requested, save backup ('*bkp.m')</a></li><li><a href="#16">Internal functions</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [codeFix,issues] = mep8(fileName,cfg,overwrite)
</pre><pre class="codeinput"><span class="comment">% Checks style issues in matlab code, fixes and overwrites if requested.</span>
</pre><h2 id="3">Input - output</h2><pre>- fileName is a *.m text file with code to check / fix
- overwrite (optional) is true or false. when true, fileName is overwritten and a
backup file is created, ending in bkp.m
- cfg (optional) is a struct with configuration fields. see cfg options below
- codeFix is a string containing fixed code
- issues contain fields describing the different issues encountered line
by line.</pre><h2 id="4">features:</h2><pre>- use checkcode.m to report code errors etc. chsckcode issues are reported
but not fixed.
- use indentcode.m to check and fix indentation issues.
- use splitcode (adapted from m2html) to process the text. This labels
strings and comments in the code, not to be touched when fixing (see
splitCode below).
- pad "=" with spaces, or any char defined in spacePad variable</pre><h2 id="5">cfg options</h2><pre>- cfg.factory = true (default) tells chekccode to ignore warning supression
previously defined by the user (e.g. %#ok comments inline). If you set
cfg.factory to false it may not be mep8 style anymore, but this is
freedom for you.
- cfg.okayIssue is an N by 1 cell array with strings indicating that some issues
are to be ignored. The default is to ignore Matlab messages about
variables changing size in a loop: cfg.okayIssue{1,1} = 'appears to change size';</pre><h2 id="6">To Do</h2><pre>- polish and test on more code
- decide what to do with * / .^ etc
- treat function names, mainly bad style e.g Func_Name
- do something about line lengths
- check scope of short varNames
- offer iStart for istart and starti
- treat comments: capital 1st letter, function statment last comment,
space after %, empty line after last informative comment
- accept directory, perhaps also recursively</pre><h2 id="7">website</h2><p>See author, license and more stuff here https://yuval-harpaz.github.io/mep8/ (click view on github) [codeFix,issues] = mep8(fileName,cfg,overwrite)</p><h2 id="8">Assign default values</h2><p>when no fileName is given (no such var or empty) take default test file</p><pre class="codeinput">fileName = defaultVal(<span class="string">'fileName'</span>,[fileparts(which(<span class="string">'mep8.m'</span>)),<span class="string">'/tests/test1.m'</span>]);
<span class="keyword">if</span> ~isequal(fileName(end-1:end),<span class="string">'.m'</span>)
    tmp = which(fileName);
    <span class="keyword">if</span> ~isempty(tmp)
        fileName = tmp;
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~exist(fileName,<span class="string">'file'</span>)
    error([fileName,<span class="string">' not found'</span>])
<span class="keyword">end</span>
overwrite = defaultVal(<span class="string">'overwrite'</span>,false); <span class="comment">% overwrite file and save backup?</span>
spacePad = <span class="string">'&gt;&lt;=|&amp;'</span>; <span class="comment">% which stuff to pad with spaces</span>
noSpaceNear = <span class="string">'~&gt;&lt;=|&amp;'</span>; <span class="comment">% between which chars not to isert space, e.g. ~=   &amp;&amp;</span>
cfg = defaultVal(<span class="string">'cfg'</span>,struct);
<span class="keyword">if</span> ~isfield(cfg,<span class="string">'okayIssue'</span>)
    cfg.okayIssue{1,1} = <span class="string">'appears to change size'</span>; <span class="comment">% okay with mep8 to change size of a variable within a loop</span>
<span class="keyword">end</span>
<span class="keyword">if</span> ~isfield(cfg,<span class="string">'factory'</span>)
    cfg.factory = true; <span class="comment">% okay with mep8 to change size of a variable within a loop</span>
<span class="keyword">end</span>
</pre><h2 id="9">check compatibility / code warnings</h2><pre class="codeinput">disp(<span class="string">'running checkcode: '</span>)
<span class="keyword">if</span> cfg.factory
    issuesCodecheck = checkcode(fileName,<span class="string">'-string'</span>,<span class="string">'-config=factory'</span>);
<span class="keyword">else</span>
    issuesCodecheck = checkcode(fileName,<span class="string">'-string'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> ~isempty(issuesCodecheck)
    <span class="keyword">if</span> isfield(cfg,<span class="string">'okayIssue'</span>)
        <span class="keyword">for</span> iOkay = 1:length(cfg.okayIssue)
            deleteMessage = strfind(issuesCodecheck,cfg.okayIssue{iOkay});
            <span class="keyword">if</span> ~isempty(deleteMessage)
                rmLoc = false(1,length(issuesCodecheck));
                <span class="keyword">for</span> iMsg = 1:length(deleteMessage)
                    nlLoc = find(ismember(issuesCodecheck,newline));
                    <span class="comment">% next newline</span>
                    nl1 = nlLoc(find(nlLoc &gt; deleteMessage(iMsg),1));
                    <span class="comment">% previous newline</span>
                    nl0 = nlLoc(find(nlLoc &lt; deleteMessage(iMsg),1,<span class="string">'last'</span>));
                    <span class="keyword">if</span> isempty(nl0)
                        rmLoc(1:nl1) = true;
                    <span class="keyword">else</span>
                        rmLoc(nl0+1:nl1) = true;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                issuesCodecheck(rmLoc) = [];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% process code to find variable names etc</span>
<span class="comment">% see http://undocumentedmatlab.com/blog/parsing-mlint-code-analyzer-output</span>

<span class="keyword">if</span> isempty(issuesCodecheck)
    fprintf(<span class="string">'\b no issues\n\n'</span>)
<span class="keyword">else</span>
    disp(issuesCodecheck);
<span class="keyword">end</span>
issues.codeCheck = issuesCodecheck;
</pre><pre class="codeoutput">running checkcode: 
L 4 (C 12): Extra semicolon is unnecessary in FOR statement before newline.

</pre><h2 id="10">read text file</h2><pre class="codeinput">fr = fopen(fileName);
codeOrig = native2unicode(fread(fr,<span class="string">'uint8=&gt;uint8'</span>)');
fclose(fr);
<span class="comment">% replace return \r with newline \n</span>
codeOrig = regexprep(codeOrig, <span class="string">'\r\n?'</span>, <span class="string">'\n'</span>);
<span class="comment">% make sure last character is newline</span>
<span class="keyword">if</span> ~isequal(codeOrig(end),newline)
    codeOrig(end+1) = newline;
<span class="keyword">end</span>
</pre><h2 id="11">use matlab automatic indentation to add / remove spaces</h2><pre class="codeinput">disp(<span class="string">'checking bad indentation:'</span>)
codeFix = indentcode(codeOrig);
<span class="comment">% find newline location in orig (0) and new text (1)</span>
newLines0 = regexp(codeOrig,<span class="string">'\n'</span>);
newLines1 = regexp(codeFix,<span class="string">'\n'</span>);
<span class="keyword">if</span> ~isequal(length(newLines0),length(newLines1))
    error(<span class="string">'indented code and orig have different numbers of lines'</span>);
<span class="keyword">end</span>
<span class="comment">%location of line beginning in texts</span>
startLine0 = [1,newLines0(1:end-1)+1];
startLine1 = [1,newLines1(1:end-1)+1];
<span class="comment">% go line by line and check differences in spaces location</span>
<span class="comment">% along the way, process codeFix and label the contents</span>
<span class="comment">%</span>
content = repmat(<span class="string">'c'</span>,1,length(codeFix)); <span class="comment">% c  is for code (not cookey)</span>
codeFixRow = nan(size(codeFix));
content(strfind(codeFix,newline)) = <span class="string">'n'</span>;
issuesIndent = <span class="string">''</span>;
<span class="keyword">for</span> linei = 1:length(startLine0)
    line0 = codeOrig(startLine0(linei):newLines0(linei)-1);
    line1 = codeFix(startLine1(linei):newLines1(linei)-1);
    spaceMessage = <span class="string">''</span>;
    linStr = num2str(linei);
    spaceIdx0 = ismember(line0,<span class="string">' '</span>);
    spaceIdx1 = ismember(line1,<span class="string">' '</span>);
    <span class="comment">% check length of indentation</span>
    <span class="keyword">if</span> isempty(line0)
        indent0 = 0;
    <span class="keyword">else</span>
        indent0 = find(~spaceIdx0,1);
    <span class="keyword">end</span>
    indent1 = find(~spaceIdx1,1);

    <span class="keyword">if</span> isempty(indent1) &amp;&amp; any(spaceIdx1) <span class="comment">% a codeFix line with nothing but spaces</span>
        indent1 = sum(spaceIdx1);
        content(startLine1(linei):startLine1(linei)+length(line1)-1) = <span class="string">'i'</span>;
    <span class="keyword">elseif</span> indent1 &gt; 1 <span class="comment">% a line with spaces and then something else</span>
        content(startLine1(linei):startLine1(linei)+indent1-2) = <span class="string">'i'</span>;
    <span class="keyword">end</span>
    codeFixRow(startLine1(linei):newLines1(linei)) = linei;
    <span class="comment">% split to look for strings and comments (from m2html)</span>
    splitc = splitCode(line1);
    start = startLine1(linei); <span class="comment">% marks beginning of split strings</span>
    <span class="keyword">for</span> spliti = 1:length(splitc)
        <span class="keyword">if</span> ~isempty(splitc{spliti})
            <span class="keyword">switch</span> splitc{spliti}(1)
                <span class="keyword">case</span> <span class="string">'%'</span>
                    content(start:start+length(splitc{spliti})-1) = <span class="string">'%'</span>;
                <span class="keyword">case</span> <span class="string">''''</span>
                    content(start:start+length(splitc{spliti})-1) = <span class="string">''''</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        start = start+length(splitc{spliti}); <span class="comment">% location of next split</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> ~strcmp(line0,line1)
        <span class="keyword">if</span> indent1 &gt; indent0
            num = num2str(indent1-indent0);
            spaceMessage = [<span class="string">'Add '</span>,num,<span class="string">' spaces. '</span>];
        <span class="keyword">elseif</span> indent1 &lt; indent0
            num = num2str(indent0-indent1);
            spaceMessage = [<span class="string">'remove '</span>,num,<span class="string">' spaces. '</span>];
        <span class="keyword">end</span>
        <span class="keyword">if</span> sum(~spaceIdx0) == sum(~spaceIdx1)
            lastNotSpace0 = find(~spaceIdx0,1,<span class="string">'last'</span>);
            lastNotSpace1 = find(~spaceIdx1,1,<span class="string">'last'</span>);
            <span class="keyword">if</span> lastNotSpace1 &lt; length(line1)
                error(<span class="string">'last fixed charecter should not be space'</span>)
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(lastNotSpace0)
                lastNotSpace0 = 0; <span class="comment">% only spaces in a line</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> lastNotSpace0 &lt; length(line0)
                spaceMessage = [spaceMessage,num2str(length(line0)-lastNotSpace0),<span class="keyword">...</span>
                    <span class="string">' extra spaces in end of line'</span>];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        addMessage = true;
        <span class="keyword">if</span> isfield(cfg,<span class="string">'okayIssue'</span>)
            <span class="keyword">for</span> iOkay = 1:length(cfg.okayIssue)
                okayInMsg = strfind(spaceMessage,cfg.okayIssue{iOkay});
                <span class="keyword">if</span> ~isempty(okayInMsg)
                    addMessage = false;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> addMessage
            issuesIndent = [issuesIndent,<span class="string">'L '</span>,linStr,<span class="string">': '</span>,spaceMessage,newline];
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(issuesIndent)
    fprintf(<span class="string">'\b no issues \n\n'</span>)
<span class="keyword">else</span>
    disp(issuesIndent)
<span class="keyword">end</span>
issues.indent = issuesIndent;
</pre><pre class="codeoutput">checking bad indentation:
L 5: Add 2 spaces. 2 extra spaces in end of line
L 8: Add 2 spaces. 
L 10: Add 4 spaces. 3 extra spaces in end of line
L 16: Add 4 spaces. 

</pre><h2 id="12">look for '=' or other stuff to pad with spaces</h2><pre class="codeinput">disp([<span class="string">'padding '</span>,spacePad,<span class="string">' with spaces: '</span>])
issuesSpace = <span class="string">''</span>;
doPadding = true;
<span class="keyword">if</span> isfield(cfg,<span class="string">'okayIssue'</span>)
    <span class="keyword">for</span> iOkay = 1:length(cfg.okayIssue)
        okayInMsg = strfind(<span class="string">' padded with spaces.'</span>,cfg.okayIssue{iOkay});
        <span class="keyword">if</span> ~isempty(okayInMsg)
            doPadding = false;
            fprintf(<span class="string">'\b skipping because of cfg.okayIssue \n\n'</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">if</span> doPadding

    toPad = ismember(codeFix,spacePad);
    insertSpace = toPad; <span class="comment">% make space after "="</span>
    insertSpace(find(toPad)-1) = true; <span class="comment">% make space before "="</span>
    <span class="comment">% find ~= &lt;= and &gt;=</span>
    logi = find(ismember(codeFix,noSpaceNear));
    <span class="keyword">if</span> ~isempty(logi)
        <span class="comment">%spacei = find(insertSpace);</span>
        [~,ii] = ismember(logi,find(toPad)-1);
        <span class="keyword">if</span> any(ii)
            logi = logi(ii &gt; 0);
            insertSpace(logi) = false;
            insertSpace(logi-1) = true;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    insertSpace(ismember(codeFix,<span class="string">' '</span>)) = false; <span class="comment">% dont insert space after space</span>
    insertSpace(find(ismember(codeFix,<span class="string">' '</span>))-1) = false;  <span class="comment">% dont insert space before space</span>
    <span class="comment">% avoid analyzing strings and comments</span>
    insertSpace(ismember(content,<span class="string">'%'</span>)) = false;
    insertSpace(ismember(content,<span class="string">''''</span>)) = false;
    <span class="keyword">if</span> sum(insertSpace) &gt; 0
        <span class="keyword">if</span> isfield(cfg,<span class="string">'dbg'</span>)
            tmp1 = <span class="string">'code                                               '</span>;
            tmp1(2,:) = <span class="string">'insert space after                                 '</span>;
            tmp1(3,:) = [<span class="string">'c=code, %=comment, i=indent, '''</span>,<span class="string">'=string, n=newline   '</span>];
            tmp2 = strrep(num2str(insertSpace),<span class="string">' '</span>,<span class="string">''</span>);
            tmp2 = strrep(tmp2,<span class="string">'0'</span>,<span class="string">'_'</span>);
            tmp2 = strrep(tmp2,<span class="string">'1'</span>,<span class="string">'^'</span>);
            tmp3 = [strrep(codeFix,newline,<span class="string">'N'</span>);tmp2;content];
            disp(<span class="string">'location of "insert space after"'</span>);
            disp([tmp1,tmp3]);
        <span class="keyword">end</span>
        <span class="keyword">if</span> ~isempty(unique(content(insertSpace))) &amp;&amp; ~isequal(unique(content(insertSpace)),<span class="string">'c'</span>)
            error(<span class="string">'space insertion not in code "c"'</span>)
        <span class="keyword">end</span>
        spacedLines = unique(codeFixRow(insertSpace));
        <span class="keyword">for</span> linei = 1:length(spacedLines)
            loc = find(insertSpace &amp; codeFixRow == spacedLines(linei));
            padded = spacePad(ismember(spacePad,codeFix(loc(1)-1:loc(end))));
            issuesSpace = [issuesSpace,<span class="string">'L '</span>,num2str(spacedLines(linei)),<span class="string">': '</span>,<span class="keyword">...</span>
                padded,<span class="string">' padded with spaces.'</span>,newline];
        <span class="keyword">end</span>
        disp(issuesSpace)
        <span class="comment">% Here we actually do the space padding</span>
        <span class="keyword">for</span> inserti = sort(find(insertSpace),<span class="string">'descend'</span>)
            codeFix = insertAfter(codeFix,inserti,<span class="string">' '</span>);
            content = insertAfter(content,inserti,<span class="string">'c'</span>);
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        fprintf(<span class="string">'\b no issues\n\n'</span>)
    <span class="keyword">end</span>
<span class="keyword">end</span>
issues.spacePad = issuesSpace;
</pre><pre class="codeoutput">padding &gt;&lt;=|&amp; with spaces: 
L 4: = padded with spaces.
L 5: = padded with spaces.
L 7: = padded with spaces.
L 8: = padded with spaces.
L 9: = padded with spaces.
L 10: = padded with spaces.
L 11: &lt;= padded with spaces.
L 13: = padded with spaces.
L 18: = padded with spaces.

</pre><h2 id="13">variable names</h2><pre class="codeinput">disp(<span class="string">'checking variable names:'</span>)
issuesVarNames = <span class="string">''</span>;
cCodeEdit = checkcode(fileName,<span class="string">'-edit'</span>); <span class="comment">% -ty gives variable lines</span>
<span class="keyword">if</span> isempty(cCodeEdit)
    fprintf(<span class="string">'\b no variables found\n\n'</span>)
<span class="keyword">else</span>
    cCodeEdit = cCodeEdit(1).message;
    varLines = regexp(cCodeEdit,newline,<span class="string">'split'</span>)';
    varLines = varLines(contains(varLines,<span class="string">' V '</span>));
    cCodeTY = checkcode(fileName,<span class="string">'-ty'</span>);
    cCodeTY = cCodeTY(1).message;
    <span class="keyword">if</span> isempty(varLines)
        fprintf(<span class="string">'\b no variables found\n\n'</span>)
    <span class="keyword">else</span>
        <span class="comment">% get variable names from text</span>
        spaceLims = find(diff(ismember(varLines{1},<span class="string">' '</span>)) &gt; 0,2)+1;
        varNames = cellfun(@(x) strrep(x(spaceLims(1):spaceLims(2)),<span class="string">' '</span>,<span class="string">''</span>),<span class="keyword">...</span>
            varLines, <span class="string">'UniformOutput'</span>,false);
        varNames = unique(varNames);
        startWithUpper = cellfun(@(x) isequal(x(1),upper(x(1))),varNames);
        <span class="keyword">if</span> any(startWithUpper)
            <span class="keyword">for</span> iUpper1 = find(startWithUpper)'
                <span class="comment">%tmp4 = join(varNames(startWithUpper)');</span>
                issuesVarNames = [issuesVarNames,<span class="keyword">...</span>
                    <span class="string">'L '</span>,varL(varNames{iUpper1},cCodeTY),<span class="string">': Variable '</span>,varNames{iUpper1},<span class="keyword">...</span>
                    <span class="string">' starts with an uppercase letter'</span>,newline];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="comment">% check scope of short name variables</span>
        varLength = cellfun(@(x) length(x),varNames);
        <span class="keyword">for</span> len = 1:4
            varsToCheck = find(varLength == len);
            <span class="keyword">if</span> ~isempty(varsToCheck)
                <span class="keyword">for</span> iVar = 1:length(varsToCheck)
                    [line1str,allLines] = varL(varNames(varsToCheck(iVar)),cCodeTY);
                    scope = range(allLines)+1;
                    <span class="comment">% here we allow scope to be 15 lines * name length</span>
                    <span class="keyword">if</span> scope &gt; len*15
                        issuesVarNames = [issuesVarNames,<span class="string">'L '</span>,line1str,<span class="keyword">...</span>
                            <span class="string">': '</span>,varNames{varsToCheck(iVar)},<span class="string">' has a scope of '</span>,<span class="keyword">...</span>
                            num2str(scope),<span class="string">' lines. Name length should be at least '</span>,<span class="keyword">...</span>
                            num2str(min(ceil(scope/15),6)),<span class="string">' chars long'</span>,newline];
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="comment">% look for two words such as finaltest</span>
        <span class="keyword">if</span> exist(<span class="string">'words4mep8.mat'</span>,<span class="string">'file'</span>)
            load <span class="string">words4mep8</span> <span class="string">words</span>
        <span class="keyword">else</span>
            <span class="keyword">try</span>
                words = urlread(<span class="string">'https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english.txt'</span>);
                words = regexp(words,newline,<span class="string">'split'</span>)';
                exclude = cellfun(@(x) length(x),words) &lt; 2; <span class="comment">% single letters are not words</span>
                exclude(123+find(cellfun(@(x) length(x),words(124:end)) == 2)) = true; <span class="comment">% two letters (infrequent, below 130) are not words</span>
                words(exclude) = [];
            <span class="keyword">catch</span>
                disp(<span class="string">'words list requires internet connection'</span>)
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> exist(<span class="string">'words'</span>,<span class="string">'var'</span>)
            <span class="keyword">for</span> vari = 1:length(varNames)
                <span class="keyword">if</span> length(varNames{vari}) &gt; 5 <span class="comment">% dont try to combine two words if the name is short</span>
                    <span class="keyword">if</span> ~ismember(varNames{vari},words) <span class="keyword">...</span><span class="comment"> % variable name is not a word</span>
                            &amp;&amp; ~contains(varNames{vari},<span class="string">'_'</span>) <span class="keyword">...</span><span class="comment"> % no underscore</span>
                            &amp;&amp; isequal(varNames{vari},lower(varNames{vari})) <span class="comment">% no upper-case letters</span>
                        <span class="keyword">for</span> cutPoint = 3:length(varNames{vari})-2
                            w1 = ismember(lower(varNames{vari}(1:cutPoint)),words);
                            w2 = ismember(lower(varNames{vari}(cutPoint+1:end)),words);
                            <span class="keyword">if</span> w1 &amp;&amp; w2
                                optionCap = [lower(varNames{vari}(1:cutPoint)),<span class="keyword">...</span>
                                    upper(varNames{vari}(cutPoint+1)),lower(varNames{vari}(cutPoint+2:end))];
                                <span class="keyword">if</span> ~isequal(varNames{vari},optionCap)
                                    var1stLine = varL(varNames{vari},cCodeTY);
                                    issuesVarNames = [issuesVarNames,[<span class="string">'L '</span>,var1stLine,<span class="keyword">...</span>
                                        <span class="string">': Consider renaming '</span>,varNames{vari},<span class="string">' as '</span>,optionCap,newline]];
                                <span class="keyword">end</span>
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            warning(<span class="string">'unable to get a list of words to check variable names for wordness'</span>)
        <span class="keyword">end</span>
        <span class="comment">% see that variable names do not shadow existing functions</span>
        <span class="keyword">for</span> vari = 1:length(varNames)
            otherUses = existDict(varNames{vari});
            <span class="keyword">if</span> ~isempty(otherUses)
                issuesVarNames = [issuesVarNames,<span class="string">'L '</span>,varL(varNames{vari},cCodeTY),<span class="string">': Variable '</span>,otherUses,newline];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">% sort the messages by line number</span>
    <span class="keyword">if</span> isempty(issuesVarNames)
        fprintf(<span class="string">'\b no issues\n\n'</span>)
    <span class="keyword">else</span>
        issuesVarNames = regexp(issuesVarNames(1:end-1),newline,<span class="string">'split'</span>);
        lNum = cell2mat(cellfun(@(x) str2double(x(3:strfind(x,<span class="string">':'</span>)-1)),<span class="keyword">...</span>
            issuesVarNames,<span class="string">'UniformOutput'</span>,false));
        [~,order] = sort(lNum);
        issuesVarNames = issuesVarNames(order);
        issuesVarNames = join([issuesVarNames',repmat({newline},length(issuesVarNames),1)]);
        issuesVarNames = join(issuesVarNames);
        issuesVarNames = issuesVarNames{1};
        issuesVarNames = strrep(issuesVarNames,[newline,<span class="string">' L'</span>],[newline,<span class="string">'L'</span>]);
        disp(issuesVarNames);
    <span class="keyword">end</span>
<span class="keyword">end</span>
issues.varNames = issuesVarNames;
</pre><pre class="codeoutput">checking variable names:
L 1: Variable CONST1 starts with an uppercase letter 
L 8: Variable Xup starts with an uppercase letter 
L 30: Consider renaming finaltest as finalTest 
L 32: Variable sphere is a file with extension .m, .mlx, or .mlapp, .mat, .fig, or .txt) 

</pre><h2 id="14">line length 80?</h2><h2 id="15">overwrite if requested, save backup ('*bkp.m')</h2><pre class="codeinput"><span class="keyword">if</span> overwrite &amp;&amp; ~isequal(codeFix,codeOrig)
    [pat1,pat2,pat3] = fileparts(fileName);
    <span class="keyword">if</span> ~isempty(pat1)
        pat1 = [pat1,<span class="string">'/'</span>];
    <span class="keyword">end</span>
    bkpNew = false;
    jj = 0;
    <span class="keyword">while</span> bkpNew == false
        jj = jj+1;
        backup = [pat1,pat2,<span class="string">'_'</span>,num2str(jj),<span class="string">'bkp'</span>,pat3];
        <span class="keyword">if</span> ~exist(backup,<span class="string">'file'</span>)
            bkpNew = true;

            fbkp = fopen(backup,<span class="string">'w'</span>);
            fwrite(fbkp,codeFix);
            fclose(fbkp);
            <span class="keyword">if</span> ~exist(backup,<span class="string">'file'</span>)
                error(<span class="string">'backup file not created, not overwriting'</span>)
            <span class="keyword">end</span>
            fw = fopen(fileName,<span class="string">'w'</span>);
            fwrite(fw,codeFix);
            fclose(fw);
            disp([<span class="string">'overwrote, backup file: '</span>,backup])
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans =

    '% this code is nonsensical, it does not run without errors. It has style
     % issues detectable by running mep8; or mep8('tests/test1.m).
     CONST1 = 15;
     for ii = 1:10;
         x = 5;
         
         if ii == 2
             Xup = x+1/3*CONST1;
         elseif ii ~= 3
             x = ii;
         elseif x &lt;= 54
             disp('x is okay I guess')
         elseif x ~= 15
             [~,order] = sort(x);
         end
         
     end
     str = 'I got  a =sign!';
     disp(str)
     % treat &lt;= respectfully
     disp(x)
     txt0 = native2unicode(fread(f,'uint8=&gt;uint8')');
     disp(['here I test 3 dots + comment               XXXXXXXXXXXXX',... % here a comment lays
         ' more string here']);
     disp('3 dots here ...  ') % more dots tests
     m = 5+3+10000-...
         34;
     x = x+3+10000-...
         35; % comment here?
     finaltest = x+3+10000-...
         35; % comment there? with 'qoutes'?
     sphere = 2*pi;
     
     '

</pre><h2 id="16">Internal functions</h2><pre class="codeinput"><span class="keyword">function</span> val = defaultVal(varName,defValue)
<span class="comment">% assigns defValue to varName when varName does not exist or empty</span>
<span class="keyword">if</span> evalin(<span class="string">'caller'</span>,[<span class="string">'exist('''</span>,varName,<span class="string">''','</span>,<span class="string">'''var'''</span>,<span class="string">');'</span>])
    val = evalin(<span class="string">'caller'</span>,varName);
<span class="keyword">else</span>
    val = [];
<span class="keyword">end</span>
<span class="keyword">if</span> isempty(val)
    val = defValue;
<span class="keyword">end</span>

<span class="keyword">function</span> splitc = splitCode(code2split)
<span class="comment">% adapted from m2html</span>
<span class="comment">% splits line of Matlab code CODE into a cell</span>
<span class="comment">%  array SPLITC where each element is either a character array ('...'),</span>
<span class="comment">%  a comment (%...), a continuation (...) or something else.</span>
<span class="comment">%  Note that CODE = [SPLITC{:}]</span>
<span class="comment">%</span>
<span class="comment">%  See also M2HTML, HIGHLIGHT</span>
<span class="comment">%  GNU 2.0 license or later</span>
<span class="comment">%  Copyright (C) 2003 Guillaume Flandin &lt;Guillaume@artefact.tk&gt;</span>


<span class="comment">%- Label quotes in {'transpose', 'beginstring', 'midstring', 'endstring'}</span>
iquote = strfind(code2split,<span class="string">''''</span>);
quotetransp = [double(<span class="string">'_''.)}]'</span>) <span class="keyword">...</span>
    double(<span class="string">'A'</span>):double(<span class="string">'Z'</span>) <span class="keyword">...</span>
    double(<span class="string">'0'</span>):double(<span class="string">'9'</span>) <span class="keyword">...</span>
    double(<span class="string">'a'</span>):double(<span class="string">'z'</span>)];
flagString = 0;
flagdoublequote = 0;
jquote = [];
<span class="keyword">for</span> iq = 1:length(iquote)
    <span class="keyword">if</span> ~flagString
        <span class="keyword">if</span> iquote(iq) &gt; 1 &amp;&amp; any(quotetransp == double(code2split(iquote(iq)-1)))
            <span class="comment">% =&gt; 'transpose';</span>
        <span class="keyword">else</span>
            <span class="comment">% =&gt; 'beginstring';</span>
            jquote(size(jquote,1)+1,:) = [iquote(iq) length(code2split)];
            flagString = 1;
        <span class="keyword">end</span>
    <span class="keyword">else</span> <span class="comment">% if flagstring</span>
        <span class="keyword">if</span> flagdoublequote || <span class="keyword">...</span>
                (iquote(iq) &lt; length(code2split) &amp;&amp; strcmp(code2split(iquote(iq)+1),<span class="string">''''</span>))
            <span class="comment">% =&gt; 'midstring';</span>
            flagdoublequote = ~flagdoublequote;
        <span class="keyword">else</span>
            <span class="comment">% =&gt; 'endstring';</span>
            jquote(size(jquote,1),2) = iquote(iq);
            flagString = 0;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%- Find if a portion of code is a comment</span>
ipercent = strfind(code2split,<span class="string">'%'</span>);
jpercent = [];
<span class="keyword">for</span> ip = 1:length(ipercent)
    <span class="keyword">if</span> isempty(jquote) || <span class="keyword">...</span>
            ~any((ipercent(ip) &gt; jquote(:,1)) &amp; (ipercent(ip) &lt; jquote(:,2)))
        jpercent = [ipercent(ip) length(code2split)];
        <span class="keyword">break</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">%- Remove strings inside comments</span>
<span class="keyword">if</span> ~isempty(jpercent) &amp;&amp; ~isempty(jquote)
    jquote(jquote(:,1) &gt; jpercent(1),:) = [];
<span class="keyword">end</span>

<span class="comment">%- Split code in a cell array of strings</span>
icode = [jquote ; jpercent];
splitc = {};
<span class="keyword">if</span> isempty(icode)
    splitc{1} = code2split;
<span class="keyword">elseif</span> icode(1,1) &gt; 1
    splitc{1} = code2split(1:icode(1,1)-1);
<span class="keyword">end</span>
<span class="keyword">for</span> ic = 1:size(icode,1)
    splitc{end+1} = code2split(icode(ic,1):icode(ic,2));
    <span class="keyword">if</span> ic &lt; size(icode,1) &amp;&amp; icode(ic+1,1) &gt; icode(ic,2) + 1
        splitc{end+1} = code2split((icode(ic,2)+1):(icode(ic+1,1)-1));
    <span class="keyword">elseif</span> ic == size(icode,1) &amp;&amp; icode(ic,2) &lt; length(code2split)
        splitc{end+1} = code2split(icode(ic,2)+1:end);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">function</span> str = existDict(var4existDict)
<span class="comment">% check what sort of thing is var4existDict</span>
existNum = exist(var4existDict); <span class="comment">%#ok&lt;EXIST&gt;</span>
str = <span class="string">''</span>;
<span class="keyword">switch</span> existNum
    <span class="keyword">case</span> 0
        str = <span class="string">''</span>; <span class="comment">%if NAME does not exist</span>
    <span class="keyword">case</span> 1
        str = <span class="string">''</span>; <span class="comment">% NAME is a variable in the workspace</span>
    <span class="keyword">case</span> 2
        str = [var4existDict,<span class="string">' is a file with extension .m, .mlx, or .mlapp, .mat, .fig, or .txt)'</span>];
    <span class="keyword">case</span> 3
        str = [var4existDict,<span class="string">' is a MEX-file on the MATLAB search path'</span>];
    <span class="keyword">case</span> 4
        str = [var4existDict,<span class="string">' is a Simulink model or library file on the MATLAB search path'</span>];
    <span class="keyword">case</span> 5
        str = [var4existDict,<span class="string">' is a built-in MATLAB function'</span>];
    <span class="keyword">case</span> 6
        str = [var4existDict,<span class="string">' is a P-code file on the MATLAB search path'</span>];
    <span class="keyword">case</span> 7
        str = <span class="string">''</span>; <span class="comment">% a folder</span>
    <span class="keyword">case</span> 8
        str = [var4existDict,<span class="string">' is a class'</span>];
<span class="keyword">end</span>

<span class="keyword">function</span> [line1str,allLines] = varL(vName,ccTYf)
<span class="comment">% Returns the first appearance of a variable (line number) as a string</span>
<span class="comment">% If requested, returns all appearances in the code.</span>
<span class="keyword">if</span> nargout == 1 <span class="comment">% quickly check first instance of a variable</span>
    varInTY = strfind(ccTYf,[newline,vName,<span class="string">':'</span>]);
    varInTY = varInTY(1);
    var1stLine = regexp(ccTYf(varInTY:end),<span class="string">'\d*'</span>,<span class="string">'match'</span>);
    line1str = var1stLine{1};
<span class="keyword">elseif</span> nargout == 2
    ccTYlines = regexp(ccTYf,newline,<span class="string">'split'</span>);

    <span class="keyword">if</span> isequal(ccTYlines{1}(1:10),<span class="string">'FUNCTIONS:'</span>) <span class="comment">% maybe always true</span>
        ccTYlines(1) = [];
    <span class="keyword">end</span>
    <span class="keyword">if</span> isempty(ccTYlines{end}) <span class="comment">% maybe always true</span>
        ccTYlines(end) = [];
    <span class="keyword">end</span>
    iVarLinesTY = find(cellfun(@(x) ~isequal(x(1),<span class="string">' '</span>),ccTYlines));
    varNamesTY = cellfun(@(x) x(1:strfind(x,<span class="string">':'</span>)-1),ccTYlines(iVarLinesTY),<span class="keyword">...</span>
        <span class="string">'uniformoutput'</span>,false);
    whichTYlines = find(ismember(varNamesTY,vName));
    currVarLines = [];
    <span class="keyword">for</span> iwtyl = 1:length(whichTYlines)
        nextVar = iVarLinesTY(find(iVarLinesTY &gt; iVarLinesTY(whichTYlines(iwtyl)),1));
        <span class="keyword">if</span> isempty(nextVar)
            lastLineToCheck = length(ccTYlines);
        <span class="keyword">else</span>
            lastLineToCheck = nextVar-1;
        <span class="keyword">end</span>
        linesToCheck = ccTYlines(iVarLinesTY(whichTYlines(iwtyl))+1:lastLineToCheck);
        linesToCheck = cellfun(@(x) x(strfind(x,<span class="string">':'</span>)+1:end),linesToCheck,<span class="keyword">...</span>
            <span class="string">'uniformoutput'</span>,false);
        lineStr = join(linesToCheck);
        currVarLines = [currVarLines,unique(str2double(lineStr{1}))];
    <span class="keyword">end</span>
    allLines = unique(currVarLines);
    line1str = num2str(allLines(1));
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
function [codeFix,issues] = mep8(fileName,cfg,overwrite)
% Checks style issues in matlab code, fixes and overwrites if requested.
%% Input - output
%  - fileName is a *.m text file with code to check / fix
%  - overwrite (optional) is true or false. when true, fileName is overwritten and a
% backup file is created, ending in bkp.m
%  - cfg (optional) is a struct with configuration fields. see cfg options below
%  - codeFix is a string containing fixed code
%  - issues contain fields describing the different issues encountered line
% by line.
%% features:
%  - use checkcode.m to report code errors etc. chsckcode issues are reported
% but not fixed.
%  - use indentcode.m to check and fix indentation issues.
%  - use splitcode (adapted from m2html) to process the text. This labels
% strings and comments in the code, not to be touched when fixing (see
% splitCode below).
%  - pad "=" with spaces, or any char defined in spacePad variable
%% cfg options
%  - cfg.factory = true (default) tells chekccode to ignore warning supression
% previously defined by the user (e.g. %#ok comments inline). If you set
% cfg.factory to false it may not be mep8 style anymore, but this is
% freedom for you.
%  - cfg.okayIssue is an N by 1 cell array with strings indicating that some issues
%  are to be ignored. The default is to ignore Matlab messages about
%  variables changing size in a loop: cfg.okayIssue{1,1} = 'appears to change size';
%% To Do
%  - polish and test on more code
%  - decide what to do with * / .^ etc
%  - treat function names, mainly bad style e.g Func_Name
%  - do something about line lengths
%  - check scope of short varNames
%  - offer iStart for istart and starti
%  - treat comments: capital 1st letter, function statment last comment,
%  space after %, empty line after last informative comment
%  - accept directory, perhaps also recursively
%% website
% See author, license and more stuff here https://yuval-harpaz.github.io/mep8/
% (click view on github)
% [codeFix,issues] = mep8(fileName,cfg,overwrite)


%% Assign default values
% when no fileName is given (no such var or empty) take default test file
fileName = defaultVal('fileName',[fileparts(which('mep8.m')),'/tests/test1.m']);
if ~isequal(fileName(end-1:end),'.m')
    tmp = which(fileName);
    if ~isempty(tmp)
        fileName = tmp;
    end
end
if ~exist(fileName,'file')
    error([fileName,' not found'])
end
overwrite = defaultVal('overwrite',false); % overwrite file and save backup?
spacePad = '><=|&'; % which stuff to pad with spaces
noSpaceNear = '~><=|&'; % between which chars not to isert space, e.g. ~=   &&
cfg = defaultVal('cfg',struct);
if ~isfield(cfg,'okayIssue')
    cfg.okayIssue{1,1} = 'appears to change size'; % okay with mep8 to change size of a variable within a loop
end
if ~isfield(cfg,'factory')
    cfg.factory = true; % okay with mep8 to change size of a variable within a loop
end
%% check compatibility / code warnings
disp('running checkcode: ')
if cfg.factory
    issuesCodecheck = checkcode(fileName,'-string','-config=factory');
else
    issuesCodecheck = checkcode(fileName,'-string');
end
if ~isempty(issuesCodecheck)
    if isfield(cfg,'okayIssue')
        for iOkay = 1:length(cfg.okayIssue)
            deleteMessage = strfind(issuesCodecheck,cfg.okayIssue{iOkay});
            if ~isempty(deleteMessage)
                rmLoc = false(1,length(issuesCodecheck));
                for iMsg = 1:length(deleteMessage)
                    nlLoc = find(ismember(issuesCodecheck,newline));
                    % next newline
                    nl1 = nlLoc(find(nlLoc > deleteMessage(iMsg),1));
                    % previous newline
                    nl0 = nlLoc(find(nlLoc < deleteMessage(iMsg),1,'last'));
                    if isempty(nl0)
                        rmLoc(1:nl1) = true;
                    else
                        rmLoc(nl0+1:nl1) = true;
                    end
                end
                issuesCodecheck(rmLoc) = [];
            end
        end
    end
end
% process code to find variable names etc
% see http://undocumentedmatlab.com/blog/parsing-mlint-code-analyzer-output

if isempty(issuesCodecheck)
    fprintf('\b no issues\n\n')
else
    disp(issuesCodecheck);
end
issues.codeCheck = issuesCodecheck;
%% read text file
fr = fopen(fileName);
codeOrig = native2unicode(fread(fr,'uint8=>uint8')');
fclose(fr);
% replace return \r with newline \n
codeOrig = regexprep(codeOrig, '\r\n?', '\n');
% make sure last character is newline
if ~isequal(codeOrig(end),newline)
    codeOrig(end+1) = newline;
end

%% use matlab automatic indentation to add / remove spaces
disp('checking bad indentation:')
codeFix = indentcode(codeOrig);
% find newline location in orig (0) and new text (1)
newLines0 = regexp(codeOrig,'\n');
newLines1 = regexp(codeFix,'\n');
if ~isequal(length(newLines0),length(newLines1))
    error('indented code and orig have different numbers of lines');
end
%location of line beginning in texts
startLine0 = [1,newLines0(1:end-1)+1];
startLine1 = [1,newLines1(1:end-1)+1];
% go line by line and check differences in spaces location
% along the way, process codeFix and label the contents
%
content = repmat('c',1,length(codeFix)); % c  is for code (not cookey)
codeFixRow = nan(size(codeFix));
content(strfind(codeFix,newline)) = 'n';
issuesIndent = '';
for linei = 1:length(startLine0)
    line0 = codeOrig(startLine0(linei):newLines0(linei)-1);
    line1 = codeFix(startLine1(linei):newLines1(linei)-1);
    spaceMessage = '';
    linStr = num2str(linei);
    spaceIdx0 = ismember(line0,' ');
    spaceIdx1 = ismember(line1,' ');
    % check length of indentation
    if isempty(line0)
        indent0 = 0;
    else
        indent0 = find(~spaceIdx0,1);
    end
    indent1 = find(~spaceIdx1,1);
    
    if isempty(indent1) && any(spaceIdx1) % a codeFix line with nothing but spaces
        indent1 = sum(spaceIdx1);
        content(startLine1(linei):startLine1(linei)+length(line1)-1) = 'i';
    elseif indent1 > 1 % a line with spaces and then something else
        content(startLine1(linei):startLine1(linei)+indent1-2) = 'i';
    end
    codeFixRow(startLine1(linei):newLines1(linei)) = linei;
    % split to look for strings and comments (from m2html)
    splitc = splitCode(line1);
    start = startLine1(linei); % marks beginning of split strings
    for spliti = 1:length(splitc)
        if ~isempty(splitc{spliti})
            switch splitc{spliti}(1)
                case '%'
                    content(start:start+length(splitc{spliti})-1) = '%';
                case ''''
                    content(start:start+length(splitc{spliti})-1) = '''';
            end
        end
        start = start+length(splitc{spliti}); % location of next split
    end
    
    if ~strcmp(line0,line1)
        if indent1 > indent0
            num = num2str(indent1-indent0);
            spaceMessage = ['Add ',num,' spaces. '];
        elseif indent1 < indent0
            num = num2str(indent0-indent1);
            spaceMessage = ['remove ',num,' spaces. '];
        end
        if sum(~spaceIdx0) == sum(~spaceIdx1)
            lastNotSpace0 = find(~spaceIdx0,1,'last');
            lastNotSpace1 = find(~spaceIdx1,1,'last');
            if lastNotSpace1 < length(line1)
                error('last fixed charecter should not be space')
            end
            if isempty(lastNotSpace0)
                lastNotSpace0 = 0; % only spaces in a line
            end
            if lastNotSpace0 < length(line0)
                spaceMessage = [spaceMessage,num2str(length(line0)-lastNotSpace0),...
                    ' extra spaces in end of line'];
            end
        end
        addMessage = true;
        if isfield(cfg,'okayIssue')
            for iOkay = 1:length(cfg.okayIssue)
                okayInMsg = strfind(spaceMessage,cfg.okayIssue{iOkay});
                if ~isempty(okayInMsg)
                    addMessage = false;
                end
            end
        end
        if addMessage
            issuesIndent = [issuesIndent,'L ',linStr,': ',spaceMessage,newline];
        end
    end
end
if isempty(issuesIndent)
    fprintf('\b no issues \n\n')
else
    disp(issuesIndent)
end
issues.indent = issuesIndent;

%% look for '=' or other stuff to pad with spaces
disp(['padding ',spacePad,' with spaces: '])
issuesSpace = '';
doPadding = true;
if isfield(cfg,'okayIssue')
    for iOkay = 1:length(cfg.okayIssue)
        okayInMsg = strfind(' padded with spaces.',cfg.okayIssue{iOkay});
        if ~isempty(okayInMsg)
            doPadding = false;
            fprintf('\b skipping because of cfg.okayIssue \n\n')
        end
    end
end
if doPadding
    
    toPad = ismember(codeFix,spacePad);
    insertSpace = toPad; % make space after "="
    insertSpace(find(toPad)-1) = true; % make space before "="
    % find ~= <= and >=
    logi = find(ismember(codeFix,noSpaceNear));
    if ~isempty(logi)
        %spacei = find(insertSpace);
        [~,ii] = ismember(logi,find(toPad)-1);
        if any(ii)
            logi = logi(ii > 0);
            insertSpace(logi) = false;
            insertSpace(logi-1) = true;
        end
    end
    insertSpace(ismember(codeFix,' ')) = false; % dont insert space after space
    insertSpace(find(ismember(codeFix,' '))-1) = false;  % dont insert space before space
    % avoid analyzing strings and comments
    insertSpace(ismember(content,'%')) = false;
    insertSpace(ismember(content,'''')) = false;
    if sum(insertSpace) > 0
        if isfield(cfg,'dbg')
            tmp1 = 'code                                               ';
            tmp1(2,:) = 'insert space after                                 ';
            tmp1(3,:) = ['c=code, %=comment, i=indent, ''','=string, n=newline   '];
            tmp2 = strrep(num2str(insertSpace),' ','');
            tmp2 = strrep(tmp2,'0','_');
            tmp2 = strrep(tmp2,'1','^');
            tmp3 = [strrep(codeFix,newline,'N');tmp2;content];
            disp('location of "insert space after"');
            disp([tmp1,tmp3]);
        end
        if ~isempty(unique(content(insertSpace))) && ~isequal(unique(content(insertSpace)),'c')
            error('space insertion not in code "c"')
        end
        spacedLines = unique(codeFixRow(insertSpace));
        for linei = 1:length(spacedLines)
            loc = find(insertSpace & codeFixRow == spacedLines(linei));
            padded = spacePad(ismember(spacePad,codeFix(loc(1)-1:loc(end))));
            issuesSpace = [issuesSpace,'L ',num2str(spacedLines(linei)),': ',...
                padded,' padded with spaces.',newline];
        end
        disp(issuesSpace)
        % Here we actually do the space padding
        for inserti = sort(find(insertSpace),'descend')
            codeFix = insertAfter(codeFix,inserti,' ');
            content = insertAfter(content,inserti,'c');
        end
    else
        fprintf('\b no issues\n\n')
    end
end
issues.spacePad = issuesSpace;

%% variable names
disp('checking variable names:')
issuesVarNames = '';
cCodeEdit = checkcode(fileName,'-edit'); % -ty gives variable lines
if isempty(cCodeEdit)
    fprintf('\b no variables found\n\n')
else
    cCodeEdit = cCodeEdit(1).message;
    varLines = regexp(cCodeEdit,newline,'split')';
    varLines = varLines(contains(varLines,' V '));
    cCodeTY = checkcode(fileName,'-ty');
    cCodeTY = cCodeTY(1).message;
    if isempty(varLines)
        fprintf('\b no variables found\n\n')
    else
        % get variable names from text
        spaceLims = find(diff(ismember(varLines{1},' ')) > 0,2)+1;
        varNames = cellfun(@(x) strrep(x(spaceLims(1):spaceLims(2)),' ',''),...
            varLines, 'UniformOutput',false);
        varNames = unique(varNames);
        startWithUpper = cellfun(@(x) isequal(x(1),upper(x(1))),varNames);
        if any(startWithUpper)
            for iUpper1 = find(startWithUpper)'
                %tmp4 = join(varNames(startWithUpper)');
                issuesVarNames = [issuesVarNames,...
                    'L ',varL(varNames{iUpper1},cCodeTY),': Variable ',varNames{iUpper1},...
                    ' starts with an uppercase letter',newline];
            end
        end
        % check scope of short name variables
        varLength = cellfun(@(x) length(x),varNames);
        for len = 1:4
            varsToCheck = find(varLength == len);
            if ~isempty(varsToCheck)
                for iVar = 1:length(varsToCheck)
                    [line1str,allLines] = varL(varNames(varsToCheck(iVar)),cCodeTY);
                    scope = range(allLines)+1;
                    % here we allow scope to be 15 lines * name length
                    if scope > len*15
                        issuesVarNames = [issuesVarNames,'L ',line1str,...
                            ': ',varNames{varsToCheck(iVar)},' has a scope of ',...
                            num2str(scope),' lines. Name length should be at least ',...
                            num2str(min(ceil(scope/15),6)),' chars long',newline];
                    end
                end
                
            end
        end
        % look for two words such as finaltest
        if exist('words4mep8.mat','file')
            load words4mep8 words
        else
            try
                words = urlread('https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english.txt');
                words = regexp(words,newline,'split')';
                exclude = cellfun(@(x) length(x),words) < 2; % single letters are not words
                exclude(123+find(cellfun(@(x) length(x),words(124:end)) == 2)) = true; % two letters (infrequent, below 130) are not words
                words(exclude) = [];
            catch
                disp('words list requires internet connection')
            end
        end
        if exist('words','var')
            for vari = 1:length(varNames)
                if length(varNames{vari}) > 5 % dont try to combine two words if the name is short
                    if ~ismember(varNames{vari},words) ... % variable name is not a word
                            && ~contains(varNames{vari},'_') ... % no underscore
                            && isequal(varNames{vari},lower(varNames{vari})) % no upper-case letters
                        for cutPoint = 3:length(varNames{vari})-2
                            w1 = ismember(lower(varNames{vari}(1:cutPoint)),words);
                            w2 = ismember(lower(varNames{vari}(cutPoint+1:end)),words);
                            if w1 && w2
                                optionCap = [lower(varNames{vari}(1:cutPoint)),...
                                    upper(varNames{vari}(cutPoint+1)),lower(varNames{vari}(cutPoint+2:end))];
                                if ~isequal(varNames{vari},optionCap)
                                    var1stLine = varL(varNames{vari},cCodeTY);
                                    issuesVarNames = [issuesVarNames,['L ',var1stLine,...
                                        ': Consider renaming ',varNames{vari},' as ',optionCap,newline]];
                                end
                            end
                        end
                    end
                end
            end
        else
            warning('unable to get a list of words to check variable names for wordness')
        end
        % see that variable names do not shadow existing functions
        for vari = 1:length(varNames)
            otherUses = existDict(varNames{vari});
            if ~isempty(otherUses)
                issuesVarNames = [issuesVarNames,'L ',varL(varNames{vari},cCodeTY),': Variable ',otherUses,newline];
            end
        end
    end
    % sort the messages by line number
    if isempty(issuesVarNames)
        fprintf('\b no issues\n\n')
    else
        issuesVarNames = regexp(issuesVarNames(1:end-1),newline,'split');
        lNum = cell2mat(cellfun(@(x) str2double(x(3:strfind(x,':')-1)),...
            issuesVarNames,'UniformOutput',false));
        [~,order] = sort(lNum);
        issuesVarNames = issuesVarNames(order);
        issuesVarNames = join([issuesVarNames',repmat({newline},length(issuesVarNames),1)]);
        issuesVarNames = join(issuesVarNames);
        issuesVarNames = issuesVarNames{1};
        issuesVarNames = strrep(issuesVarNames,[newline,' L'],[newline,'L']);
        disp(issuesVarNames);
    end
end
issues.varNames = issuesVarNames;
%% line length 80?


%% overwrite if requested, save backup ('*bkp.m')
if overwrite && ~isequal(codeFix,codeOrig)
    [pat1,pat2,pat3] = fileparts(fileName);
    if ~isempty(pat1)
        pat1 = [pat1,'/'];
    end
    bkpNew = false;
    jj = 0;
    while bkpNew == false
        jj = jj+1;
        backup = [pat1,pat2,'_',num2str(jj),'bkp',pat3];
        if ~exist(backup,'file')
            bkpNew = true;
            
            fbkp = fopen(backup,'w');
            fwrite(fbkp,codeFix);
            fclose(fbkp);
            if ~exist(backup,'file')
                error('backup file not created, not overwriting')
            end
            fw = fopen(fileName,'w');
            fwrite(fw,codeFix);
            fclose(fw);
            disp(['overwrote, backup file: ',backup])
        end
    end
end

%% Internal functions
function val = defaultVal(varName,defValue)
% assigns defValue to varName when varName does not exist or empty
if evalin('caller',['exist(''',varName,''',','''var''',');'])
    val = evalin('caller',varName);
else
    val = [];
end
if isempty(val)
    val = defValue;
end

function splitc = splitCode(code2split)
% adapted from m2html
% splits line of Matlab code CODE into a cell
%  array SPLITC where each element is either a character array ('...'),
%  a comment (%...), a continuation (...) or something else.
%  Note that CODE = [SPLITC{:}]
%
%  See also M2HTML, HIGHLIGHT
%  GNU 2.0 license or later
%  Copyright (C) 2003 Guillaume Flandin <Guillaume@artefact.tk>
%  $Revision: 1.0 $Date: 2003/29/04 17:33:43 $

%- Label quotes in {'transpose', 'beginstring', 'midstring', 'endstring'}
iquote = strfind(code2split,'''');
quotetransp = [double('_''.)}]') ...
    double('A'):double('Z') ...
    double('0'):double('9') ...
    double('a'):double('z')];
flagString = 0;
flagdoublequote = 0;
jquote = [];
for iq = 1:length(iquote)
    if ~flagString
        if iquote(iq) > 1 && any(quotetransp == double(code2split(iquote(iq)-1)))
            % => 'transpose';
        else
            % => 'beginstring';
            jquote(size(jquote,1)+1,:) = [iquote(iq) length(code2split)];
            flagString = 1;
        end
    else % if flagstring
        if flagdoublequote || ...
                (iquote(iq) < length(code2split) && strcmp(code2split(iquote(iq)+1),''''))
            % => 'midstring';
            flagdoublequote = ~flagdoublequote;
        else
            % => 'endstring';
            jquote(size(jquote,1),2) = iquote(iq);
            flagString = 0;
        end
    end
end

%- Find if a portion of code is a comment
ipercent = strfind(code2split,'%');
jpercent = [];
for ip = 1:length(ipercent)
    if isempty(jquote) || ...
            ~any((ipercent(ip) > jquote(:,1)) & (ipercent(ip) < jquote(:,2)))
        jpercent = [ipercent(ip) length(code2split)];
        break;
    end
end

%- Remove strings inside comments
if ~isempty(jpercent) && ~isempty(jquote)
    jquote(jquote(:,1) > jpercent(1),:) = [];
end

%- Split code in a cell array of strings
icode = [jquote ; jpercent];
splitc = {};
if isempty(icode)
    splitc{1} = code2split;
elseif icode(1,1) > 1
    splitc{1} = code2split(1:icode(1,1)-1);
end
for ic = 1:size(icode,1)
    splitc{end+1} = code2split(icode(ic,1):icode(ic,2));
    if ic < size(icode,1) && icode(ic+1,1) > icode(ic,2) + 1
        splitc{end+1} = code2split((icode(ic,2)+1):(icode(ic+1,1)-1));
    elseif ic == size(icode,1) && icode(ic,2) < length(code2split)
        splitc{end+1} = code2split(icode(ic,2)+1:end);
    end
end
function str = existDict(var4existDict)
% check what sort of thing is var4existDict
existNum = exist(var4existDict); %#ok<EXIST>
str = '';
switch existNum
    case 0
        str = ''; %if NAME does not exist
    case 1
        str = ''; % NAME is a variable in the workspace
    case 2
        str = [var4existDict,' is a file with extension .m, .mlx, or .mlapp, .mat, .fig, or .txt)'];
    case 3
        str = [var4existDict,' is a MEX-file on the MATLAB search path'];
    case 4
        str = [var4existDict,' is a Simulink model or library file on the MATLAB search path'];
    case 5
        str = [var4existDict,' is a built-in MATLAB function'];
    case 6
        str = [var4existDict,' is a P-code file on the MATLAB search path'];
    case 7
        str = ''; % a folder
    case 8
        str = [var4existDict,' is a class'];
end

function [line1str,allLines] = varL(vName,ccTYf)
% Returns the first appearance of a variable (line number) as a string
% If requested, returns all appearances in the code.
if nargout == 1 % quickly check first instance of a variable
    varInTY = strfind(ccTYf,[newline,vName,':']);
    varInTY = varInTY(1);
    var1stLine = regexp(ccTYf(varInTY:end),'\d*','match');
    line1str = var1stLine{1};
elseif nargout == 2
    ccTYlines = regexp(ccTYf,newline,'split');
    
    if isequal(ccTYlines{1}(1:10),'FUNCTIONS:') % maybe always true
        ccTYlines(1) = [];
    end
    if isempty(ccTYlines{end}) % maybe always true
        ccTYlines(end) = [];
    end
    iVarLinesTY = find(cellfun(@(x) ~isequal(x(1),' '),ccTYlines));
    varNamesTY = cellfun(@(x) x(1:strfind(x,':')-1),ccTYlines(iVarLinesTY),...
        'uniformoutput',false);
    whichTYlines = find(ismember(varNamesTY,vName));
    currVarLines = [];
    for iwtyl = 1:length(whichTYlines)
        nextVar = iVarLinesTY(find(iVarLinesTY > iVarLinesTY(whichTYlines(iwtyl)),1));
        if isempty(nextVar)
            lastLineToCheck = length(ccTYlines);
        else
            lastLineToCheck = nextVar-1;
        end
        linesToCheck = ccTYlines(iVarLinesTY(whichTYlines(iwtyl))+1:lastLineToCheck);
        linesToCheck = cellfun(@(x) x(strfind(x,':')+1:end),linesToCheck,...
            'uniformoutput',false);
        lineStr = join(linesToCheck);
        currVarLines = [currVarLines,unique(str2double(lineStr{1}))];
    end
    allLines = unique(currVarLines);
    line1str = num2str(allLines(1));
end

##### SOURCE END #####
--></body></html>